## Assumptions (call these out now)
1) **Cards are private** (only the owning player can see their hand; spectators can’t). With “publicly viewable games,” you still want hidden info protected. If you *don’t* care, you can simplify a lot by returning full state to everyone.

2) **Neutrals** can be attacked like normal territories; they “auto-defend” (max dice) and never take turns.

If either assumption is wrong, tell me and I’ll adjust the plan.

---

# Next Milestone Plan: Convex Backend + Vite/React Frontend

## 1) High-level architecture
You’ll have three “layers”:

1) **risk-engine (shared library)**  
   - Pure rules + deterministic reducer.
   - Used by both backend (authoritative) and frontend (UX helpers like legal moves).

2) **Convex backend (authoritative game server + persistence)**  
   - Stores: canonical game snapshots + append-only action/event log.
   - Runs: validation and `applyAction` for every submitted move.
   - Handles: auth, lobby/invites, public viewing projections, (later) notifications.

3) **Vite/React client (presentation + interaction)**  
   - Uses Convex reactive queries to stay updated without refresh.
   - Uses risk-engine locally to compute legal moves and pre-validate before submitting.
   - Calls Convex mutations for actual moves.

---

## 2) Backend plan (Convex + BetterAuth component)

### 2.1 Convex project setup (monorepo)
Add a `packages/backend` (or `apps/backend`) Convex project in the Bun monorepo:
- `convex/` functions + schema + http routes
- imports `@your-scope/risk-engine`

### 2.2 Authentication (BetterAuth Convex component)
Use the official BetterAuth Convex integration/component approach (docs: Better Auth + Convex component).

Core steps:
- Install BetterAuth + `@convex-dev/better-auth`.
- Add `convex/auth.config.ts` provider config.
- Register BetterAuth component in `convex/convex.config.ts`.
- Mount BetterAuth HTTP routes in `convex/http.ts`.
- Create a BetterAuth client for the frontend using the Convex plugin.

Email verification + password reset:
- Use the Resend Convex component (`@convex-dev/resend`) for delivery.
- Implement `sendVerificationEmail` and `sendResetPassword` in BetterAuth config using an **action context** (network call).

You said “don’t worry too much”: implement the flows minimally but correctly:
- verify-email link
- reset-password link
- basic templates (later polish)

### 2.3 Data model (Convex tables)
Use **snapshot + log**.

**Tables (suggested):**
- `maps`
  - `mapId`, `name`, `graphMap` (validated JSON), `createdAt`
  - Predefined only (no user-generated for now)
- `games`
  - `gameId`
  - `mapId`, `rulesetId` (or embedded `rulesetConfig`)
  - `state` (canonical full GameState; includes hands, deck, rng, etc.)
  - `version` (integer for optimistic concurrency)
  - `status`: `lobby | active | finished`
  - `createdBy`, `createdAt`, `startedAt`, `finishedAt`
  - `visibility`: `public | unlisted` (invite link)
- `gamePlayers`
  - `gameId`, `userId`, `playerId` (engine PlayerId), `teamId?`
  - `role`: `player | spectator` (optional)
  - `joinedAt`
- `gameInvites`
  - `gameId`, `code`, `createdAt`, `expiresAt?`
- `gameActions` (append-only)
  - `gameId`, `index`, `actorPlayerId`, `action`, `events`, `createdAt`
  - `stateHash?` (optional debugging)
- (optional) `gameChat` for lobby/game comments

Indexes you’ll want early:
- `games` by `status`, by `createdAt`
- `gamePlayers` by `gameId`, by `userId`
- `gameActions` by `gameId + index`

### 2.4 Server-side “view model” projections (public vs player)
Because games are publicly viewable but cards should be private, implement queries that return a **projection** rather than raw `state`.

Create a “GameView” shape:
- public:
  - territories ownership + armies
  - current turn + phase
  - public events summary (dice results are fine)
  - deck/discard counts (not specific card IDs in hands)
  - per-player hand size only (optional)
- authenticated player:
  - same as public
  - plus *their own hand contents*
- (optionally) admins can see all

This is the single biggest “don’t leak info” step.

### 2.5 Core backend functions (Convex)
**Lobby**
- `createGame` (mutation, auth required)
  - choose map + ruleset + lobby settings
  - create `games` row with `status=lobby`
  - create invite code row
  - add creator to `gamePlayers`
- `joinGameByInvite` (mutation, auth required)
  - validate code, add to gamePlayers if slot available
- `startGame` (mutation, auth required, only host)
  - validate lobby state
  - build engine player list (+ teams if applicable)
  - call `riskEngine.createGame(...)`
  - persist snapshot in `games.state`, set `status=active`, `version=1`
  - append `SetupCompleted` to log (optional)

**Gameplay**
- `submitAction` (mutation, auth required)
  - args: `gameId`, `expectedVersion`, `action`
  - load game snapshot
  - verify caller maps to a `playerId` in this game
  - run `riskEngine.validateAction(state, action, { actorId })`
  - if valid: `applyAction` → `nextState + events`
  - store:
    - update `games.state`, bump `version`
    - append to `gameActions` with `index = previous + 1`
- `resign` (optional mutation)
- `kickPlayer` (host only, lobby only)

**Queries**
- `getGameView(gameId)` (public)
- `getGameViewAsPlayer(gameId)` (auth; returns player-private hand)
- `listPublicGames` (public)
- `listMyGames` (auth)
- `getLobby(gameId)` (public/unlisted)

### 2.6 RNG / anti-cheat nuance (decision later)
Two options; build so you can switch:

**Option A (simpler): seed stored in game state, but never returned in public queries**
- Pros: easiest; still prevents casual cheating if you don’t expose seed
- Cons: if any query accidentally returns full state, seed leaks

**Option B (better): seed stored server-side only**
- Store `rngSeed` in a separate table or encrypted blob accessible only to internal server functions.
- `games.state` stores only `rngIndex` (or a token).
- `submitAction` reconstructs RNG stream using private seed.
- Pros: clients can’t predict dice even if they inspect game state
- Cons: a bit more backend wiring

Plan: implement Option A first with strict projections; migrate to Option B if you care.

### 2.7 Maps: predefined, but you need a “builder”
No user-generated maps now, but you still need an internal workflow.

Add `packages/maps/` (or `packages/risk-maps/`):
- map definitions as JSON/TS objects
- a small CLI script (in-repo) that:
  - validates maps using `risk-engine` map validator
  - seeds/upserts them into Convex via a restricted mutation (admin-only)

This avoids hand-editing Convex rows and keeps maps versioned in git.

---

## 3) Frontend plan (Vite + React + Tailwind v4 + shadcn/ui + Convex)

### 3.1 App foundations
- Vite React TS app in `apps/web`
- Tailwind v4 setup (Vite plugin + `@import "tailwindcss"` in global CSS)
- shadcn/ui initialization (Tailwind v4 compatible; likely the canary CLI path depending on current shadcn guidance)
- shared UI primitives:
  - layout shell
  - forms (sign in/up)
  - dialogs/sheets (lobby, trade cards)
  - toast system (shadcn now prefers Sonner)

### 3.2 Auth wiring (BetterAuth client + Convex provider)
- Use `ConvexBetterAuthProvider` + BetterAuth React client with convex plugin.
- Pages:
  - `/login`, `/signup`
  - `/verify-email` callback page
  - `/forgot-password`, `/reset-password`

### 3.3 Routing + pages (minimum)
- `/` landing (public games list, sign-in button)
- `/games/new` create lobby
- `/g/:gameId` game page
  - if `status=lobby`: lobby view (players, invite link, teams assignment)
  - if `active`: game view (board renderer + action controls)
  - if `finished`: summary + replay list (optional)
- `/u/me` profile/settings (optional)

### 3.4 Client state flow (key idea)
- Subscribe to `getGameView(gameId)` always (public view)
- If authed and player in game, also query `getGameViewAsPlayer(gameId)` for private hand
- Build UI off view model (not raw engine state)

For actions:
- use local `risk-engine` selectors + `validateAction` for UX
- submit via `submitAction` mutation with `expectedVersion`
- let Convex reactive updates update UI after mutation commits

### 3.5 Game UI components (high level)
- Board renderer (your own SVG/canvas/dom; engine is map-agnostic)
- Right panel:
  - phase indicator
  - reinforcement placement UI
  - attack controls + dice results feed
  - fortify controls
  - cards panel (hand, trade dialog)
- Lobby:
  - invite link copy
  - team selection (if enabled)
  - “Start game” button for host
- Public spectator:
  - no private hand
  - show log feed and current position

---

## 4) Execution steps (milestone checklist)

### Phase 1 — Repo + tooling
- Add `apps/web` (Vite React TS)
- Add `packages/backend` (Convex)
- Ensure both can import `packages/risk-engine`

### Phase 2 — Auth end-to-end
- BetterAuth Convex component installed and routes mounted
- Vite app can sign up/sign in
- Email verification + password reset wired via Resend

### Phase 3 — Maps + seeding
- `packages/maps` created
- Convex `maps` table + admin-only upsert mutation
- CLI seed script validates then uploads maps

### Phase 4 — Lobby + invites
- Create game lobby (host)
- Join via invite code/link
- Start game → engine `createGame` snapshot stored

### Phase 5 — Gameplay loop
- `submitAction` mutation authoritative apply + log append
- Public game view query + player-private view query
- Basic UI for placing reinforcements / attacking / fortifying / trading cards

### Phase 6 — Public viewing + hardening
- Ensure spectators can view games without leaking private hands/seed
- Add rate limits / abuse protection (basic: per-user action frequency; optional)
- Add audit-friendly logs (action index, timestamps)

---

## 5) A couple implementation decisions to confirm (small but important)
1) **Hidden info**: confirm spectators can’t see player hands (recommended).  
2) **Attacking from teammate territories**: earlier I recommended “no” (you can place/fortify on teammates, but only attack from your own territories). Still agree?

If you confirm those, I can turn this into a concrete “function/file layout plan” for `convex/` and `apps/web/src/` (still high level, no full code).
